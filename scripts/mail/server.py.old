#!/usr/bin/env python3
"""MCP server for sending, receiving, and managing email via local Postfix."""

import hashlib
import json
import os
import re
import subprocess
import sys
import tempfile
import time
import urllib.request
import urllib.error
from datetime import datetime, timezone
from pathlib import Path

from mcp.server.fastmcp import FastMCP

# Add memory directory to path for db module
sys.path.insert(0, "/home/claude/memory")
try:
    from db import log_sent_email
except ImportError:
    # Fallback if db module not available
    def log_sent_email(*args, **kwargs):
        pass

DOMAIN = "example.com"
DEFAULT_FROM = "Iris <iris@[YOUR_DOMAIN]>"
EMAILS_DIR = Path("/home/claude/docs/emails")
INDEX_PATH = EMAILS_DIR / "index.json"
READ_MBOX_SCRIPT = Path(__file__).parent / "read_mbox.py"

# Postmark API configuration
POSTMARK_API_TOKEN = os.getenv("POSTMARK_API_TOKEN", "")
POSTMARK_API_URL = "https://api.postmarkapp.com/email"
POSTMARK_STREAM = "outbound"

if not POSTMARK_API_TOKEN:
    import sys
    print("WARNING: POSTMARK_API_TOKEN environment variable not set", file=sys.stderr)

MAILBOXES = {
    "claude": "/var/mail/claude",
    "root": "/var/mail/root",
}

mcp = FastMCP("email")


# ---------------------------------------------------------------------------
# Index helpers
# ---------------------------------------------------------------------------

def _load_index() -> dict:
    """Load the email index from disk."""
    if INDEX_PATH.exists():
        with open(INDEX_PATH, "r") as f:
            return json.load(f)
    return {}


def _save_index(index: dict) -> None:
    """Atomically save the email index to disk."""
    EMAILS_DIR.mkdir(parents=True, exist_ok=True)
    tmp_fd, tmp_path = tempfile.mkstemp(dir=EMAILS_DIR, suffix=".tmp")
    try:
        with os.fdopen(tmp_fd, "w") as f:
            json.dump(index, f, indent=2, ensure_ascii=False)
        os.rename(tmp_path, INDEX_PATH)
    except Exception:
        try:
            os.unlink(tmp_path)
        except OSError:
            pass
        raise


def _hash_message_id(message_id: str) -> str:
    """Return first 12 chars of SHA-256 of the Message-ID."""
    return hashlib.sha256(message_id.encode()).hexdigest()[:12]


def _sanitize_subject(subject: str) -> str:
    """Sanitize subject for use in filename."""
    # Remove Re:/Fwd: prefixes
    s = re.sub(r"^(Re|Fwd|Fw)\s*:\s*", "", subject, flags=re.IGNORECASE)
    # Keep only alphanumeric, spaces, hyphens
    s = re.sub(r"[^a-zA-Z0-9 \-]", "", s)
    # Collapse whitespace to underscores
    s = re.sub(r"\s+", "_", s.strip())
    # Truncate
    return s[:50] if s else "no_subject"


def _parse_email_date(date_str: str) -> datetime | None:
    """Try to parse an email date string."""
    if not date_str:
        return None
    # Try email.utils first
    from email.utils import parsedate_to_datetime
    try:
        return parsedate_to_datetime(date_str)
    except Exception:
        pass
    return None


def _make_filename(date_str: str, subject: str, hash12: str) -> str:
    """Generate a deterministic filename for an email."""
    dt = _parse_email_date(date_str)
    if dt:
        prefix = dt.strftime("%Y%m%d_%H%M%S")
    else:
        prefix = "00000000_000000"
    safe_subject = _sanitize_subject(subject)
    return f"{prefix}_{safe_subject}_{hash12}.txt"


def _write_email_file(filename: str, msg: dict) -> None:
    """Write an individual email to a .txt file."""
    EMAILS_DIR.mkdir(parents=True, exist_ok=True)
    filepath = EMAILS_DIR / filename
    with open(filepath, "w") as f:
        f.write(f"Message-ID: {msg['message_id']}\n")
        f.write(f"Date: {msg['date']}\n")
        f.write(f"From: {msg['from']}\n")
        f.write(f"To: {msg['to']}\n")
        f.write(f"Subject: {msg['subject']}\n")
        f.write(f"{'=' * 60}\n\n")
        f.write(msg.get("body", "").strip())
        f.write("\n")


def _read_mbox(path: str) -> list[dict]:
    """Read an mbox file, using sudo if needed for root mailbox."""
    if not os.path.exists(path):
        return []

    # Check if we can read it directly
    if os.access(path, os.R_OK):
        cmd = ["python3", str(READ_MBOX_SCRIPT), path]
    else:
        cmd = ["sudo", "python3", str(READ_MBOX_SCRIPT), path]

    result = subprocess.run(
        cmd,
        capture_output=True,
        text=True,
        timeout=30,
    )

    if result.returncode != 0:
        raise RuntimeError(f"Failed to read {path}: {result.stderr}")

    data = json.loads(result.stdout)
    if isinstance(data, dict) and "error" in data:
        raise RuntimeError(f"Error reading {path}: {data['error']}")

    return data


# ---------------------------------------------------------------------------
# MCP Tools
# ---------------------------------------------------------------------------

@mcp.tool()
def send_email(to: str, subject: str, body: str, from_addr: str = DEFAULT_FROM, cc: str = None) -> str:
    """Send an email, trying Postmark API first with sendmail fallback.

    Args:
        to: Recipient email address (e.g. user@example.com)
        subject: Email subject line
        body: Plain text email body
        from_addr: Sender address (defaults to Iris <iris@[YOUR_DOMAIN]>)
        cc: Optional CC address (e.g. user2@example.com)
    """
    msg_id = f"<mcp-{int(time.time())}@{DOMAIN}>"

    # --- Attempt 1: Postmark API ---
    try:
        payload_dict = {
            "From": from_addr,
            "To": to,
            "Subject": subject,
            "TextBody": body,
            "MessageStream": POSTMARK_STREAM,
        }

        # Add CC if provided
        if cc:
            payload_dict["Cc"] = cc

        payload = json.dumps(payload_dict).encode("utf-8")

        req = urllib.request.Request(
            POSTMARK_API_URL,
            data=payload,
            headers={
                "Accept": "application/json",
                "Content-Type": "application/json",
                "X-Postmark-Server-Token": POSTMARK_API_TOKEN,
            },
            method="POST",
        )

        with urllib.request.urlopen(req, timeout=30) as resp:
            resp_body = json.loads(resp.read().decode("utf-8"))
            pm_message_id = resp_body.get("MessageID", msg_id)

            # Log sent email to database
            try:
                log_sent_email(
                    to_addr=to,
                    from_addr=from_addr,
                    subject=subject,
                    body=body,
                    message_id=pm_message_id
                )
            except Exception as log_err:
                # Don't fail the send if logging fails
                pass

            return (
                f"Email sent to {to} with subject \"{subject}\" "
                f"via Postmark (MessageID: {pm_message_id})"
            )

    except Exception as exc:
        postmark_err = str(exc)

    # --- Attempt 2: local sendmail fallback ---
    try:
        date_str = datetime.now(timezone.utc).strftime("%a, %d %b %Y %H:%M:%S %z")

        match = re.search(r"<([^>]+)>", from_addr)
        envelope_from = match.group(1) if match else from_addr

        cc_header = f"Cc: {cc}\n" if cc else ""

        raw = (
            f"From: {from_addr}\n"
            f"To: {to}\n"
            f"{cc_header}"
            f"Subject: {subject}\n"
            f"Date: {date_str}\n"
            f"Message-ID: {msg_id}\n"
            f"MIME-Version: 1.0\n"
            f"Content-Type: text/plain; charset=UTF-8\n"
            f"\n"
            f"{body}\n"
        )

        result = subprocess.run(
            ["/usr/sbin/sendmail", "-t", "-f", envelope_from],
            input=raw,
            capture_output=True,
            text=True,
            timeout=30,
        )

        if result.returncode != 0:
            return (
                f"ERROR: Postmark failed ({postmark_err}), "
                f"sendmail also failed (exit {result.returncode}): {result.stderr}"
            )

        # Log sent email to database
        try:
            log_sent_email(
                to_addr=to,
                from_addr=from_addr,
                subject=subject,
                body=body,
                message_id=msg_id
            )
        except Exception as log_err:
            # Don't fail the send if logging fails
            pass

        return (
            f"Email sent to {to} with subject \"{subject}\" "
            f"via sendmail fallback (Message-ID: {msg_id}) "
            f"[Postmark error: {postmark_err}]"
        )

    except Exception as fallback_exc:
        return (
            f"ERROR: Both Postmark and sendmail failed. "
            f"Postmark: {postmark_err} | sendmail: {fallback_exc}"
        )

@mcp.tool()
def check_email(mailbox_name: str = "root", limit: int = 10) -> str:
    """Check a local mbox mailbox for received emails (raw mbox view).

    Args:
        mailbox_name: Which mailbox to check - "root" or "claude" (default "root")
        limit: Maximum number of recent messages to return (default 10)
    """
    path = MAILBOXES.get(mailbox_name)
    if not path:
        return f"ERROR: Unknown mailbox '{mailbox_name}'. Available: {', '.join(MAILBOXES.keys())}"

    try:
        messages = _read_mbox(path)
    except Exception as e:
        return f"ERROR: Could not read mailbox: {e}"

    if not messages:
        return f"Mailbox '{mailbox_name}' is empty."

    recent = messages[-limit:]
    output_parts = [f"Showing {len(recent)} of {len(messages)} messages in '{mailbox_name}':\n"]

    for i, msg in enumerate(recent, 1):
        body = msg.get("body", "").strip()
        if len(body) > 1000:
            body = body[:1000] + "\n... (truncated)"

        output_parts.append(
            f"--- Message {i} ---\n"
            f"Date: {msg['date']}\n"
            f"From: {msg['from']}\n"
            f"To: {msg['to']}\n"
            f"Subject: {msg['subject']}\n"
            f"Message-ID: {msg['message_id']}\n"
            f"\n{body}\n"
        )

    return "\n".join(output_parts)


@mcp.tool()
def sync_emails() -> str:
    """Scan all mbox files for new emails, extract them to individual .txt files, and update the index.

    Returns a summary of what was found and synced.
    """
    index = _load_index()
    new_count = 0
    errors = []

    for mbox_name, mbox_path in MAILBOXES.items():
        try:
            messages = _read_mbox(mbox_path)
        except Exception as e:
            errors.append(f"Error reading {mbox_name}: {e}")
            continue

        for msg in messages:
            message_id = msg.get("message_id", "").strip()
            if not message_id:
                # Generate a fallback ID from content
                content = f"{msg.get('from', '')}{msg.get('date', '')}{msg.get('subject', '')}"
                message_id = f"<generated-{hashlib.sha256(content.encode()).hexdigest()[:16]}>"
                msg["message_id"] = message_id

            hash12 = _hash_message_id(message_id)

            # Skip if already in index
            if hash12 in index:
                continue

            # New email - extract to file
            filename = _make_filename(msg.get("date", ""), msg.get("subject", ""), hash12)
            try:
                _write_email_file(filename, msg)
            except Exception as e:
                errors.append(f"Error writing {filename}: {e}")
                continue

            # Add to index
            index[hash12] = {
                "message_id": message_id,
                "from": msg.get("from", ""),
                "to": msg.get("to", ""),
                "subject": msg.get("subject", ""),
                "date": msg.get("date", ""),
                "read": False,
                "mailbox": mbox_name,
                "filename": filename,
                "action_todo": "",
                "action_taken": "",
            }
            new_count += 1

    _save_index(index)

    parts = [f"Sync complete. {new_count} new email(s) found. {len(index)} total in index."]
    if errors:
        parts.append(f"\nErrors ({len(errors)}):")
        for err in errors:
            parts.append(f"  - {err}")

    return "\n".join(parts)


@mcp.tool()
def check_new_emails(auto_sync: bool = True) -> str:
    """Check for new/unread emails. This is the main tool for ongoing email monitoring.

    Args:
        auto_sync: If True (default), sync from mbox files first to pick up new deliveries.
    """
    if auto_sync:
        sync_result = sync_emails()
    else:
        sync_result = None

    index = _load_index()
    unread = {k: v for k, v in index.items() if not v.get("read", False)}

    if not unread:
        msg = "No unread emails."
        if sync_result and "new email" in sync_result:
            msg = sync_result + "\n\n" + msg
        return msg

    parts = [f"{len(unread)} unread email(s):\n"]

    # Sort by date
    sorted_unread = sorted(unread.items(), key=lambda x: x[1].get("date", ""))

    for hash12, entry in sorted_unread:
        parts.append(
            f"  [{hash12}] {entry['date']}\n"
            f"    From: {entry['from']}\n"
            f"    Subject: {entry['subject']}\n"
        )

    if sync_result and "new email" in sync_result:
        parts.insert(0, sync_result + "\n")

    return "\n".join(parts)


@mcp.tool()
def read_email(email_id: str) -> str:
    """Read a specific email by its hash ID and mark it as read.

    Args:
        email_id: The 12-character hash ID of the email (shown in square brackets in listings).
    """
    index = _load_index()

    if email_id not in index:
        return f"ERROR: Email ID '{email_id}' not found. Use list_emails() or check_new_emails() to see available IDs."

    entry = index[email_id]
    filepath = EMAILS_DIR / entry["filename"]

    if not filepath.exists():
        return f"ERROR: Email file '{entry['filename']}' not found on disk."

    with open(filepath, "r") as f:
        content = f.read()

    # Mark as read
    if not entry.get("read", False):
        entry["read"] = True
        _save_index(index)

    # Append action tracking fields if they exist
    action_parts = []
    if entry.get("action_todo"):
        action_parts.append(f"Action TODO: {entry['action_todo']}")
    if entry.get("action_taken"):
        action_parts.append(f"Action Taken: {entry['action_taken']}")
    if action_parts:
        content += f"\n{'=' * 60}\n" + "\n".join(action_parts) + "\n"

    return content


@mcp.tool()
def mark_email(email_id: str, read: bool = True) -> str:
    """Toggle the read/unread status of an email.

    Args:
        email_id: The 12-character hash ID of the email.
        read: Set to True to mark as read, False to mark as unread.
    """
    index = _load_index()

    if email_id not in index:
        return f"ERROR: Email ID '{email_id}' not found."

    index[email_id]["read"] = read
    _save_index(index)

    status = "read" if read else "unread"
    return f"Email [{email_id}] '{index[email_id]['subject']}' marked as {status}."


@mcp.tool()
def update_email_action(email_id: str, action_todo: str = None, action_taken: str = None) -> str:
    """Update the action tracking fields on an email.

    Args:
        email_id: The 12-character hash ID of the email.
        action_todo: If provided, set the action_todo field to this value.
        action_taken: If provided, set the action_taken field to this value.
    """
    index = _load_index()

    if email_id not in index:
        return f"ERROR: Email ID '{email_id}' not found."

    if action_todo is None and action_taken is None:
        return "No updates provided. Pass action_todo and/or action_taken."

    if action_todo is not None:
        index[email_id]["action_todo"] = action_todo
    if action_taken is not None:
        index[email_id]["action_taken"] = action_taken

    _save_index(index)

    parts = [f"Email [{email_id}] '{index[email_id]['subject']}' action fields updated:"]
    if action_todo is not None:
        parts.append(f"  action_todo: {action_todo}")
    if action_taken is not None:
        parts.append(f"  action_taken: {action_taken}")
    return "\n".join(parts)


@mcp.tool()
def list_emails(mailbox: str = "all", only_unread: bool = False, limit: int = 20) -> str:
    """List emails from the index with flexible filtering.

    Args:
        mailbox: Filter by mailbox name ("claude", "root", or "all"). Default "all".
        only_unread: If True, only show unread emails. Default False.
        limit: Maximum number of emails to return. Default 20.
    """
    index = _load_index()

    if not index:
        return "No emails in index. Run sync_emails() first."

    # Filter
    filtered = {}
    for k, v in index.items():
        if mailbox != "all" and v.get("mailbox") != mailbox:
            continue
        if only_unread and v.get("read", False):
            continue
        filtered[k] = v

    if not filtered:
        return f"No emails match filters (mailbox={mailbox}, only_unread={only_unread})."

    # Sort by date descending (newest first)
    sorted_emails = sorted(filtered.items(), key=lambda x: x[1].get("date", ""), reverse=True)
    shown = sorted_emails[:limit]

    parts = [f"Showing {len(shown)} of {len(filtered)} emails (total in index: {len(index)}):\n"]

    for hash12, entry in shown:
        read_marker = " " if entry.get("read", False) else "*"
        entry_text = (
            f"  {read_marker} [{hash12}] {entry.get('date', 'no date')}\n"
            f"    From: {entry.get('from', '?')} | To: {entry.get('to', '?')}\n"
            f"    Subject: {entry.get('subject', '(no subject)')}\n"
            f"    Mailbox: {entry.get('mailbox', '?')}\n"
        )
        if entry.get("action_todo"):
            entry_text += f"    Action TODO: {entry['action_todo']}\n"
        if entry.get("action_taken"):
            entry_text += f"    Action Taken: {entry['action_taken']}\n"
        parts.append(entry_text)

    parts.append("(* = unread)")
    return "\n".join(parts)


@mcp.tool()
def check_mail_log(lines: int = 20) -> str:
    """Check recent mail server logs for delivery status.

    Args:
        lines: Number of recent log lines to return (default 20)
    """
    result = subprocess.run(
        ["tail", f"-{lines}", "/var/log/mail.log"],
        capture_output=True,
        text=True,
        timeout=10,
    )
    if result.returncode != 0:
        return f"ERROR: {result.stderr}"
    return result.stdout


if __name__ == "__main__":
    mcp.run(transport="stdio")
